#include <iostream>
//https://www.acmicpc.net/problem/1449

/*
수리공 항승

문제
항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.

파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.

항승이는 길이가 L인 테이프를 무한개 가지고 있다.

항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.

물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.

입력
첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.

출력
첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.


G
1. arr에 정수를 담는거보다 조금더 객관적이라고 생각이 듬
2. case 분리해서 일찍끝나게 함
3. do while을 잘썻다 ㅇㅈ

B
1. 구상은 잘했는데, 구현하는 도중에 이를 해맸음. 메모장에 적어놓으면 좋을 것 같음.
2. 그래서 시간이 오래 걸림. 결국 해결법을 찾긴했는데 내 문제는 구현력일 듯
3. 논리적으로 이해하기 보다 실행시켜보며 때려맞춤.

*/
int find_next_idx(int last,bool* data)
{
	int i= last;
	for(;i<1001;i++)
		if(data[i])
			return i;
	return 0;
}
int main()
{
	int N,L,cnt = 0;
	bool data[1001] = {false,};
	scanf("%d %d ",&N,&L);
	if(L == 1)
	{
		printf("%d",N);
		return 0;
	}
	if(N == 1)
	{
		printf("1");
		return 0;
	}
	for(int i=0;i<N;i++)
	{
		int num;
		scanf("%d",&num);
		data[num] = true;
	}
	int idx=find_next_idx(0,data);
	do
	{
		idx += L;
		cnt++;
		if(cnt > 100) break;
	}
	while(idx = find_next_idx(idx,data));
	printf("%d",cnt);
}

/*
 적어놨떤거
6 3
1 2 3 4 5 6	d : 5
3

5 3
1 2 3 4 5	d : 4
2

4 3
1 2 3 4		d : 3
2


3 3
1 2 3		d : 2
2

2 3
1 2			d : 1
1

L이 3일 때,
d+2  <= L*n을 만족하는, 최소 n이 사용된 테이프의 수이다.

1~5일 때,
5끝에 붙였냐
5.5에 붙였냐
6.5에 붙였냐
.
.
.
7끝에 붙였냐 까지 붙였냐의 경우가 있음.

수[1]의 L-0.5[2]까지는 커버가 됨.
3부터는 영향이 있음.  -> 5까지는 연속이라도 칭해도 된다.
4부터는 영향이X

arr[i] - idx >= L 		영향X	
1,4경우 기준점은 4가된다. cnt =

arr[i] - idx >= L -1	연속 찾는데는 영향O 테이프 갯수는 영향X	
1,3경우 기준점은 4(idx+L)가된다. cnt =

arr[i] - idx >= L -2	연속 찾는데도 영향O 테이프 갯수에도 영향O	
1,2의 경우 기준점은 4(idx+L)가 된다. cnt+

연속 찾는다는게 기준점인 idx를 어디로 옮기느냐를 의미함.

*/