#include <iostream>
//https://www.acmicpc.net/problem/1449


/*
동전 0
시간제한	2초
메모리제한	256MB

문제
항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.

파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.

항승이는 길이가 L인 테이프를 무한개 가지고 있다.

항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.

물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.

입력
첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.

출력
첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.


G
1 그리디 알고리즘의 전형적인 문제를 바로 풀수있었다.
2 case분리를 하였는데 잘했지만 case가 최대 10개라 무의미했다.
3 빨리풀긴했다. 20분정도
B
1 while문을 이용했는데 for문을 이용하는게 더 가시성이 좋다.
2 if문으로 비교하는 문장은 필요가 없었다 가시성을 해쳤다.
3 idx가 아니라 i를 썻으면 더 좋았을것같다. 여기서 한번 틀렸다. (idx의 값을 설정하는 부분에서)

Q1.도중에 멈춰도 작동하나?
A1. O

TS : 20m

*/

int main()
{
	int N,K,cnt = 0, idx;
	int money[11];
	
	scanf("%d %d",&N,&K);
	idx = N - 1 ; //오류 케이스 보고 ㅁ나듬
	for(int i=0;i<N;i++)
	{
		scanf("%d",money + i);
		if(money[i] > K)
		{
			idx = i-1;
			i= 12;
		}
	}
	while(idx >= 0 && K != 0)
	{
		cnt += K / money[idx];
		K = K %money[idx];
		idx--;
	}
	printf("%d",cnt);
	
	//오류 케이스 1 17 1 일 때
	
}